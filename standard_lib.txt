// List of all simulated bodies
Body[] __BODY_REGISTRY = [];
// List of all active rain events
__RAIN_EVENT[] __RAIN_EVENTS = [];
// Internal simulation day counter (day 0 = pre-sim snapshot)
Val __DAY = 0;

class Body {
	String label;

	Area area;
	Volume volume;
	Volume sources;
	Volume sinks;
	Body[] inflows;
	Body[] outflows;
	Volume[] outflow_rates;

	Volume[] __history;

	Body(Area area, Volume initial_volume) {
		this.label = "";
		this.area = area;
		this.volume = initial_volume;
		this.sources = 0L;
		this.sinks = 0L;
		this.inflows = [];
		this.outflows = [];
		this.outflow_rates = [];
		this.__history = [];
		__BODY_REGISTRY.push(this);
	}

	Body(String label, Area area, Volume initial_volume) {
		this.label = label;
		this.area = area;
		this.volume = initial_volume;
		this.sources = 0L;
		this.sinks = 0L;
		this.inflows = [];
		this.outflows = [];
		this.outflow_rates = [];
		this.__history = [];
		__BODY_REGISTRY.push(this);
	}

	None __apply_source() {
		this.volume = this.volume + this.sources;
	}

	None __apply_sink() {
		this.volume = this.volume - this.sinks;
		if (this.volume < 0L) {
			this.volume = 0L;
		}
	}
}

// Internal class, Stores events about rain
class __RAIN_EVENT {
	Body body;
	Rain total_rainfall;
	Val[] kernel;
	Val day;

	__RAIN_EVENT(Body body, Rain total_rainfall, Val[] kernel) {
		this.body = body;
		this.total_rainfall = total_rainfall;
		this.kernel = kernel;
		this.day = 0;
	}

	None __apply() {
		if (this.day >= this.kernel.length) {
			return;
		}
		Volume todays_inflow = this.kernel[this.day] * this.total_rainfall * this.body.area;
		this.body.volume = this.body.volume + todays_inflow;
		this.day = this.day + 1;
	}
}

Val __index_of_body(Body b) {
	for (Val i = 0; i < __BODY_REGISTRY.length; i = i + 1) {
		if (b == __BODY_REGISTRY[i]) {
			return i;
		}
	}
	return -1;
}

Bool __array_contains_body(Body[] arr, Body b) {
	for (Val i = 0; i < arr.length; i = i + 1) {
		if (arr[i] == b) {
			return true;
		}
	}
	return false;
}

Val __index_of_body_in(Body[] arr, Body b) {
	for (Val i = 0; i < arr.length; i = i + 1) {
		if (arr[i] == b) {
			return i;
		}
	}
	return -1;
}

// DFS over outflows: is there a path from 'from' to 'to'?
Bool __has_path_outflow(Body from, Body to) {
	Body[] stack = [];
	Body[] visited = [];
	stack.push(from);
	while (stack.length > 0) {
		Body cur = stack.pop();
		if (__array_contains_body(visited, cur)) {
			continue;
		}
		visited.push(cur);
		if (cur == to) {
			return true;
		}
		for (Val i = 0; i < cur.outflows.length; i = i + 1) {
			stack.push(cur.outflows[i]);
		}
	}
	return false;
}

// Topological order (Kahn) over current graph; asserts DAG
Body[] __compute_topo_order() {
	Val N = __BODY_REGISTRY.length;
	Val[] indeg = [];
	for (Val i = 0; i < N; i = i + 1) {
		indeg.push(__BODY_REGISTRY[i].inflows.length);
	}
	Body[] order = [];
	Body[] q = [];
	for (Val i = 0; i < N; i = i + 1) {
		if (indeg[i] == 0) {
			q.push(__BODY_REGISTRY[i]);
		}
	}

	Val head = 0;
	while (head < q.length) {
		Body u = q[head];
		head = head + 1;
		order.push(u);
		for (Val k = 0; k < u.outflows.length; k = k + 1) {
			Body v = u.outflows[k];
			Val vi = __index_of_body(v);
			indeg[vi] = indeg[vi] - 1;
			if (indeg[vi] == 0) {
				q.push(v);
			}
		}
	}
	assert(order.length == N, "graph must be a DAG");
	return order;
}

None __snapshot_history() {
	for (Val i = 0; i < __BODY_REGISTRY.length; i = i + 1) {
		Body b = __BODY_REGISTRY[i];
		b.__history.push(b.volume);
	}
}

None remove_body(Body body) {
	// 1) Remove all edges to/from this body
	for (Val i = 0; i < __BODY_REGISTRY.length; i = i + 1) {
		Body b = __BODY_REGISTRY[i];
		Val idx = __index_of_body_in(b.outflows, body);
		if (idx >= 0) {
			b.outflows.removeAt(idx);
			b.outflow_rates.removeAt(idx);
		}
		Val idx2 = __index_of_body_in(b.inflows, body);
		if (idx2 >= 0) {
			b.inflows.removeAt(idx2);
		}
	}
	// 2) Remove any rain events targeting this body
	for (Val i = __RAIN_EVENTS.length - 1; i >= 0; i = i - 1) {
		if (__RAIN_EVENTS[i].body == body) {
			__RAIN_EVENTS.removeAt(i);
		}
	}
	// 3) Remove from registry
	for (Val i = 0; i < __BODY_REGISTRY.length; i = i + 1) {
		if (body == __BODY_REGISTRY[i]) {
			__BODY_REGISTRY.removeAt(i);
		}
	}
}

// Connect with cycle check; duplicate updates the rate
None connect(Body start, Body outflow, Volume max_flow_rate) {
	assert(!(start == outflow), "Cannot connect a body to itself.");
	assert(!__has_path_outflow(outflow, start), "connect forms a cycle");
	Val idx = __index_of_body_in(start.outflows, outflow);
	if (idx >= 0) {
		start.outflow_rates[idx] = max_flow_rate;
	} else {
		start.outflows.push(outflow);
		start.outflow_rates.push(max_flow_rate);
		outflow.inflows.push(start);
	}
}
None connect(Body start, Body outflow) {
	connect(start, outflow, -1.0L);
}

None disconnect(Body start, Body outflow) {
	Val idx = __index_of_body_in(start.outflows, outflow);
	if (idx >= 0) {
		start.outflows.removeAt(idx);
		start.outflow_rates.removeAt(idx);
	}
	Val idx2 = __index_of_body_in(outflow.inflows, start);
	if (idx2 >= 0) {
		outflow.inflows.removeAt(idx2);
	}
}

None source(Body body, Volume amount) {
	assert(amount > 0L, "Source amount must be greater than 0!");
	body.sources = body.sources + amount;
}

None remove_source(Body body, Volume amount) {
	body.sources = body.sources - amount;
	if (body.sources < 0L) {
		body.sources = 0L;
	}
}

None sink(Body body, Volume amount) {
	assert(amount > 0L, "Sink amount must be greater than 0!");
	body.sinks = body.sinks + amount;
}

None remove_sink(Body body, Volume amount) {
	body.sinks = body.sinks - amount;
	if (body.sinks < 0L) {
		body.sinks = 0L;
	}
}

// Equalise a single parentâ†’child pair w.r.t current heights; respect per-edge cap and parent availability.
// Returns how much was sent.
Volume __equalise_pair(Body p, Body c, Volume edge_cap) {
	if (p.volume <= 0L) {
		return 0L;
	}

	Rain hp = p.volume / p.area;
	Rain hc = c.volume / c.area;
	if (hp <= hc) {
		return 0L;
	}

	// Target common height if unconstrained
	Rain hstar = (hp * p.area + hc * c.area) / (p.area + c.area);
	Volume need = (hstar - hc) * c.area;
	if (need < 0L) {
		need = 0L;
	}

	Volume cap = edge_cap;
	if (cap < 0L) {
		cap = need; // unlimited this step (still clamped by parent volume)
	}
	Volume send = need;
	if (send > cap) {
		send = cap;
	}
	if (send > p.volume) {
		send = p.volume;
	}

	if (send > 0L) {
		p.volume = p.volume - send;
		c.volume = c.volume + send;
	}
	return send;
}

// Distribute from a single parent to its children by repeatedly equalising with the currently lowest child.
None __distribute_from_parent(Body p) {
	Val k = p.outflows.length;
	if (k == 0) {
		return;
	}

	// Remaining per-edge caps for this day
	Volume[] rem = [];
	for (Val i = 0; i < k; i = i + 1) {
		Volume r = p.outflow_rates[i];
		if (r < 0L) {
			r = -1.0L; // keep negative to mean unlimited
		}
		rem.push(r);
	}

	while (p.volume > 0L) {
		Rain hp = p.volume / p.area;
		Val best = -1;
		Rain best_h = 0mm;
		Bool found = false;

		for (Val i = 0; i < k; i = i + 1) {
			if (rem[i] == 0L) {
				continue;
			}
			Body c = p.outflows[i];
			Rain hc = c.volume / c.area;
			if (hc < hp) {
				if (!found || hc < best_h) {
					best = i;
					best_h = hc;
					found = true;
				}
			}
		}
		if (!found) {
			break;
		}

		Body child = p.outflows[best];
		Volume cap = rem[best];
		Volume moved = __equalise_pair(p, child, cap);
		if (cap >= 0L) {
			rem[best] = rem[best] - moved;
		}
		if (moved <= 0L) {
			break;
		}
	}
}

// One-day wavefront: process bodies in topological order; each parent pushes and commits immediately.
None __propagate_flows_one_day() {
	Body[] order = __compute_topo_order();
	for (Val i = 0; i < order.length; i = i + 1) {
		__distribute_from_parent(order[i]);
	}
}

None rain(Body body, Rain amount, Val[] kernel) {
	Val sum = 0;
	for (Val i = 0; i < kernel.length; i = i + 1) {
		sum = sum + kernel[i];
	}
	assert(sum <= 1.0, "Kernel must sum to less than 1.0!");
	__RAIN_EVENTS.push(__RAIN_EVENT(body, amount, kernel));
}

None rain(Body body, Rain amount) {
	rain(body, amount, [1]);
}

None simulate(Val days) {
	if (__DAY == 0) {
		__snapshot_history();
	}
	for (Val i = 0; i < days; i = i + 1) {
		// 1) Sources
		for (Val j = 0; j < __BODY_REGISTRY.length; j = j + 1) {
			__BODY_REGISTRY[j].__apply_source();
		}
		// 2) Rain
		for (Val j = 0; j < __RAIN_EVENTS.length; j = j + 1) {
			__RAIN_EVENTS[j].__apply();
		}
		// 3) Wavefront: topological cascade
		__propagate_flows_one_day();
		// 4) Sinks
		for (Val j = 0; j < __BODY_REGISTRY.length; j = j + 1) {
			__BODY_REGISTRY[j].__apply_sink();
		}
		// Cleanup expired rain
		for (Val k = __RAIN_EVENTS.length - 1; k >= 0; k = k - 1) {
			__RAIN_EVENT e = __RAIN_EVENTS[k];
			if (e.day >= e.kernel.length) {
				__RAIN_EVENTS.removeAt(k);
			}
		}
		__snapshot_history();
		__DAY = __DAY + 1;
	}
}

None simulate() {
	simulate(1);
}

String __body_label(Body b) {
	if (b.label == "") {
		return "Body";
	}
	return b.label;
}

String repeat(String ch, Val n) {
	String out = "";
	for (Val i = 0; i < n; i = i + 1) out = out + ch;
	return out;
}
String rpad(String s, Val width) {
	Val pad = width - str(s).length;
	if (pad <= 0) return s;
	return s + repeat(" ", pad);
}

// Prints a nice hydrology report on a set of bodies
None hydrology_report(Body[] bodies) {
	// Determine max days we have in history for any selected body
	Val max_days = 0;
	for (Val i = 0; i < bodies.length; i = i + 1) {
		Body b = bodies[i];
		if (b.__history.length > max_days) {
			max_days = b.__history.length;
		}
	}
	if (max_days <= 0) max_days = 1; // avoid degenerate "Day -1" widths

	// Prepare labels and per-column widths (max of header vs all cell contents)
	String[] labels = [];
	Val[] col_widths = [];
	for (Val i = 0; i < bodies.length; i = i + 1) {
		String lbl = __body_label(bodies[i]);
		labels.push(lbl);
		Val w = str(lbl).length;

		for (Val d = 0; d < max_days; d = d + 1) {
			Body b = bodies[i];
			Volume v = 0L;
			if (d < b.__history.length) v = b.__history[d];

			Volume delta = 0L;
			if (d > 0 && d - 1 < b.__history.length) {
				delta = b.__history[d] - b.__history[d - 1];
			}

			String dv = str(delta);
			if (delta >= 0L) dv = "+" + dv;

			String cell = str(v) + " (" + dv + ")";
			Val cell_len = str(cell).length;
			if (cell_len > w) w = cell_len;
		}
		col_widths.push(w);
	}

	// Compute table measurements
	Val day_col_width = str("Day " + (max_days - 1) + ":").length;
	Val seps = bodies.length;
	// " | " is 3 chars
	Val row_len = day_col_width + (3 * seps);
	for (Val i = 0; i < col_widths.length; i = i + 1) row_len = row_len + col_widths[i];

	// Header
	print(repeat("-", row_len));
	print_raw("Hydrology Report");
	print(repeat(" ", row_len - 2 - str("Hydrology Report").length));
	print(repeat("-", row_len));

	// Column header row
	String sep = " | ";
	print_raw(rpad("Day:", day_col_width));
	print_raw(sep);
	for (Val i = 0; i < labels.length; i = i + 1) {
		print_raw(rpad(labels[i], col_widths[i]));
		if (i + 1 < labels.length) print_raw(sep);
	}
	print("");

	// Header underline
	print_raw(repeat("-", day_col_width));
	print_raw("-+-");
	for (Val i = 0; i < col_widths.length; i = i + 1) {
		print_raw(repeat("-", col_widths[i]));
		if (i + 1 < col_widths.length) print_raw("-+-");
	}
	print("");

	// Rows per day
	for (Val d = 0; d < max_days; d = d + 1) {
		print_raw(rpad("Day " + d + ":", day_col_width));
		print_raw(sep);

		for (Val i = 0; i < bodies.length; i = i + 1) {
			Body b = bodies[i];

			Volume v = 0L;
			if (d < b.__history.length) v = b.__history[d];

			Volume delta = 0L;
			if (d > 0 && d - 1 < b.__history.length) {
				delta = b.__history[d] - b.__history[d - 1];
			}

			String dv = str(delta);
			if (delta >= 0L) dv = "+" + dv;

			String cell = str(v) + " (" + dv + ")";
			print_raw(rpad(cell, col_widths[i]));

			if (i + 1 < bodies.length) print_raw(sep);
		}
		print("");
	}

	// Footer
	print(repeat("-", row_len));
}

// Print on a single body
None hydrology_report(Body body) {
	hydrology_report([ body ]);
}

// Print over every body. Note it can be heavy because it may print an extreme amount of bodies
None hydrology_report() {
	hydrology_report(__BODY_REGISTRY);
}